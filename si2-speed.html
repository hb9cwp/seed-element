<link rel="import" href="./bower_components/polymer/polymer.html">

<polymer-element name="si2-speed" attributes="width height background color speed webClients author">

  <template>
    <link rel="stylesheet" href="si2-speed.css">

    <h2>Hello from speed</h2>
    <p>Air speed is <strong>{{speed}}</strong> kts</p>
    <p><strong>{{webClients}}</strong> Web clients are connected.</p>
    
    <content></content>

    <div id="canvasContainer">
      <!-- <canvas id="canvasID" class="canvasClass" width="{{width}}" height="{{height}}"></canvas> -->
      <canvas id="canvas0" width="{{width}}" height="{{height}}"></canvas>
      <canvas id="canvas1" width="{{width}}" height="{{height}}"></canvas>
    </div>

  </template>

  <script>
    'use strict';
    Polymer({
      width: 300,
      height: 300,
      background: 'white',
      color: 'black',
      speed: 0,
      webClients: 0,
      author: 'Rolf Sommerhalder',
      
      ctx1: null,
      hand: null,
      
      min: 0,
      max: 0,
      angles: [],

      // on read, not on created, unlike shown in some examples!
      ready: function () {
        var that= this
        // using label ID
        var canvas0 = this.$.canvas0;
        var canvas1 = this.$.canvas1;
        // or using class
        //var canvas= this.shadowRoot.querySelector('.canvasClass')
        var ctx0 = canvas0.getContext('2d')
        that.ctx1 = canvas1.getContext('2d')
    
        var dial= new Image()
        that.hand= new Image()
        
        dial.onload = function(){
          //ctx0.drawImage(dial,0,0,dial.width,dial.height);
          //ctx0.drawImage(dial,0,0);
          ctx0.drawImage(dial,0,0,that.width,that.height);  // scale to canvas size
        }
        dial.src= "speed.png"
        
        that.hand.onload = function() {
          // 1. Move context to the center point of rotation (defaults to upper left (0,0)).
          that.ctx1.translate(that.hand.width/2, that.hand.height/2);
          // 2. Rotate
          that.ctx1.rotate((0*Math.PI/180));
          // 3. Move back with negative offsets, and draw
          //that.ctx1.drawImage(that.hand,-that.hand.width/2,-that.hand.height/2,that.hand.width,that.hand.height);
          that.ctx1.drawImage(that.hand,-that.hand.width/2,-that.hand.height/2,that.width,that.height); // scale to canvas size
        }
        that.hand.src= "speed-dial.png"
        
        // interpolation etc. 
        setup(this);
      },
      /*
      speedChange: function (speed) {
        that.ctx1.clearRect(0, 0, canvasWidth, canvasHeight);
        that.ctx1.translate(that.hand.width/2, that.hand.height/2);
        that.ctx1.rotate((speed*Math.PI/180));
        that.ctx1.drawImage(that.hand,-that.hand.width/2,-that.hand.height/2,that.hand.width,that.hand.height);
      }
      */
      
    });
    
    function setup(that) {
      // from
      //  https://github.com/dmolin/flightSimPanels/blob/master/src/services/measures/speed/client/speed.js
      console.log("setup() started...")
      
      var interp = {
        "0": 0.01,
        "5": 31,
        "7": 50,
        "10": 72,
        "12": 93,
        "15": 116,
        "17": 140,
        "20": 164,
        "22": 186,
        "25": 205,
        "27": 221,
        "30": 237,
        "32": 251,
        "35": 265,
        "37": 278,
        "40": 290,
        "42": 303,
        "45": 317
      },
      zeroAngle = 0,
      angles = [];
      
      var keys = Object.keys(interp).sort(function(a, b) {
        return parseInt(a, 10) - parseInt(b, 10);
      });
      
      var min = parseInt(keys[0], 10),
        max = parseInt(keys[keys.length - 1], 10);

      for (var i = min; i <= max; i++) {
        if (interp[i]) {
          angles[i] = interp[i] + zeroAngle;
        }
      }

      for (var i = 0, x = keys.length - 1; i < x; i++) {
        var current_key = parseInt(keys[i], 10);
        var current_val = parseInt(interp[current_key], 10);
        var next_key = parseInt(keys[i + 1], 10);
        var next_val = parseInt(interp[next_key], 10);
        var diff = (next_val - current_val) / (next_key - current_key);

        for (var q = current_key + 1, z = next_key; q < z; q++) {
          angles[q] = angles[q - 1] + diff;
        }
      }
      that.min = min;
      that.max = max;
      that.angles = angles;
      console.log("setup() done!")
    }

  </script>

</polymer-element>
